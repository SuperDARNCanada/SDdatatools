#!/bin/sh
#-----------------------------------------#
#       Author: Marina Schmidt            #
#-----------------------------------------#


#************* NOTE ******************#
# Following Bash style guide          #
#*************************************#
# https://google.github.io/styleguide/shell.xml#File_Extensions

#---------------------------------------
#   Convection Map script
#---------------------------------------
#
#What does this script do? 
#   1. Unzips fitcon data for a given date and hemisphere
#   2. Places all data into a folder with the date and hemisphere in the folder name
#   3. Obtains omni files from the website (if needed) for the given date
#   4. Parses omni file to IMF format
#   5. Generates convections maps for the given day (post script format .ps)
#   6. Converts post script files to pdf format
#   7. Reports all errors to stderr and warnings to stdout 
#
#----------------------------------------
#   How to run
#---------------------------------------
#   1. Get off your chair and move your legs really fast (joking)
#   2. step one! Make sure rst is installed 
#   3. Make sure you have the fitcon data and extensions files 
#   4. Run: 
#           ./mappot_fitcon.sh <hemisphere (north or south)> <YYYYMMDD>
#   5. If you want it to run with verbose output:
#           ./mappot_fitcon.sh <hemisphere (north or south)> <YYYYMMDD> -vb
#
#   Example:
#       To generate convection maps for the southern hemisphere for the date 2017-11-01
#       $ ./mappot_fitcon.sh south 20171101 
#       To generate convection maps for the northern hemisphere for the date 2017-11-01
#       $ ./mappot_fitcon.sh north 20171101
#       with the verbose option
#       $ ./mappot_fitcon.sh north 20171101 -vb



#What do those exit values mean? 

#----------------------------------------
#       Exit value list
#----------------------------------------
# -1 : command error
# 0  : successful
# 1  : not enough arguements
# 2  : file not found
# 3  : empty file
# 4  : segfault
# 5  : rst function failure



#-------------------------------------------
#   Default values
#-------------------------------------------

INTEGRATIONTIME=120 # 120 seconds -> 2 minutes, standard integration time
MINIMUMRANGE=2  
FMAX=30000000
VEMAX=1000000
DELAY=600 # 600 seconds -> 10 minutes this is the defualt delay time for omni sattalite information
#KEYFILE="../rainbow.key"
#------------------------------------------
#   Functions to make my life easier 
#------------------------------------------




#----------------------------------------
#arguement_check:
#   simple if statement to check 
#       if there is enough arguements
# purpose: to reduce code copying 
#
# parameters: 
#       $1: number of arguements
#       $2: expected number
#       $3: Usage message
#--------------------------------------

function arguement_check(){
    
    # $# - number of arguements
    if [ $# -ne 3 ]
    then 
        echo "Error: $# passed in, expecting 3" >&2
        echo "Usage: arguement_check <number of arguements> <expected number> <usage message>" >&2
        exit 1;
    fi

    if [ $1 -ne $2 ]
    then
        echo "Error: $1 passed in, expecting $2" >&2
        echo "Usage: $3" >&2
        exit 1;
    fi
}



#----------------------------------------
#error_check:
#   simple if statement to check if there is an error
# purpose: to reduce code copying 
#
# parameters: 
#       $1: exit value of the function
#       $2: function name 
#       $3: error code value 
#               (please look at exit list to know what to send)
#--------------------------------------

function error_check(){
     
    # $# - number of arguements
    arguement_check $# 3 "error_check <exit value of the function> <function name> <error code value>"

    if [ $1 -ne 0 ]
    then
        echo "Error: $2 function exited with the following value: $1" >&2
        if [ $1 -eq 139 ]
        then
            echo "Error: Segfault occured" >&2
            exit 4;
        fi
        exit $3;
    fi
}

#------------------------------------------------------
#warning_check:
#   simple if statement to check if there is an error
# purpose: same reason as error_check but sometimes
#          we do not want to exit the script
#
# parameters: 
#       $1: exit value of the function
#       $2: function name 
#------------------------------------------------------

function warning_check(){
     
    # $# - number of arguements   
    arguement_check $# 2 "warning_check <exit value of the function> <function name>"

    if [ $1 -ne 0 ]
    then
        echo "Warning: $2 function exited with the following value: $1"
    fi
}


#------------------------------------------------------
#warning_file_check:
#   simple if statement to check if a file is empty
# purpose: minimizing copying 
#
# parameters: 
#       $1: file name
#------------------------------------------------------

function warning_file_check()
{
     # $# - number of arguements
     arguement_check $# 1 "warning_file_check <file name>"
   
     # -s checks if the file has a size of 0
     if [ ! -s "$1" ]
     then
         echo "Warning: $1 is empty, it will not be included in the convection map process"
         rm -f $1
         return -1;
     fi
     return 0;

}
#------------------------------------------------------
#file_check:
#   simple if statement to check if a file is empty
# purpose: minimizing copying
#   calls warning_file_check as it does the same thing
#   however, exits the code. 
#   Sometimes empty files lead to segfaults later on :/
#
# parameters: 
#       $1: file name
#------------------------------------------------------


function file_check()
{

    # $# - number of arguements
    arguement_check $# 1 "file_check <file name>"

    warning_file_check $1 > /dev/null
    # $? - return value of the previously ran command
    if [ $? -ne 0 ]
    then
        echo "Error: $1 is empty"
        exit 3;
    fi
}



#------------------------------------------------------
#warning_file_check:
#   Remove rst files
# purpose: To remove all extra generated files from 
#           the convection map process.
# Note: this code is called later in the code to allow
#       for debugging purposes just in case something
#       goes wrong. 
#
# parameters: 
#       $1: file name
#------------------------------------------------------

function cleanup()
{

    # $# - number of arguements
    arguement_check $# 1 "cleanup <file name>"


    rm -f ${1}.grd 
    rm -f ${1}.*.grid

    rm -f ${1}.hmb.map
    rm -f ${1}.*.map
    rm -f ${1}.empty.map
}


#
#TODO: Maybe move this function to its own script because users may find it useful for other projects? 
#

#
#TODO: Get solar wind information :) 
#

#------------------------------------------------------
#get_omni_file:
#   Obtains omni file from: https://omniweb.sci.gsfc.nasa.gov/form/omni_min.html
#       then formats it into IMF format
# purpose: Download and parse omni data into an IMF format 
#
# parameters: 
#       $1: date
#------------------------------------------------------

function get_omni_file()
{
 
    # $# - number of arguements
    arguement_check $# 1 "get_omni_file <date>"

    #Same trick rst uses
    #Convert to EPOCH UNIX time to save the grief on determining the past days date
    local epoch_date=`date +%s -d "$1 0000"`
    epoch_date=$((epoch_date - 600))
    
    #Omni on does the dates upto the hour so we cannot put minutes in
    #However, rst does account for extra data added to the file and will look for when the ground time and the delayed sattalite time matches up. 
    #We just need to make sure we are far enough back in the past... or else rst just substitutes 9999 in ... le sigh
    local start_date=`date -d @$epoch_date +"%Y%m%d%H"`
    

    #Timming how fast downloading a daily file takes
    if [ "$verbose" == "-vb" ]
    then
        local START=$(date +%s.%N)
    fi

     #Submit the omni variables to the website and obtain the url where the lst file is stored
   
    local omni_url=`curl -d  "activity=ftp&res=min&spacecraft=omni_min&start_date=${start_date}&end_date=${1}23&vars=13&vars=14&vars=17&vars=18&submit=Submit" https://omniweb.sci.gsfc.nasa.gov/cgi/nx1.cgi \
                        | grep -oh http.*.lst\" \
                        | grep -oh http.*.lst `
    # -z : checks if the content of a variable is zero "empty"
    if [ -z $omni_url ]
    then
        echo "Warning: No Omni file for this given date: $1 "
        return 2;
    fi

    #for some reason the url is http but to curl (download) the file you need https
    # because that is where it is actually stored... 
    #using sed to replace http with  https
    corrected_url=`sed 's\http\https\g' <<< $omni_url`
    
    #download the omni file for the given data
    #The original omni file is kept for debugging purposes :)        
    curl $corrected_url > omni_${1}_original.txt

    if [ "$verbose" == "-vb" ]
    then 
        local END=$(date +%s.%N)
        local DIFF=$(echo "$END - $START" | bc)
        echo "curl download time: $DIFF seconds"
    fi

    local omni_file=omni_${1}_original.txt
    local bad_imf_data=0
    local imf_data=0

    
    #doy- day of the year
    #Note: We do not throw away bad data, rst knows how to handle it... sort of
    #      Refer to IMF observations of the readme to see various outcomes. 
    while IFS=" " read -r year doy hour minute IMFmagnitude bx by bz;
    do 
        imf_data=$((imf_data + 1))
        # $bx%%.* <-- gets the whole number
        # bash has a funny way of comparing floats so this is easier... 
        if [ "${bx%%.*}" -gt 999  ]
        then
            bad_imf_data=$((bad_imf_data + 1))
        fi

        local month=`date -d "${year}0101 + ${doy} days - 1 day" +"%m"`
        local day=`date -d "${year}0101 + ${doy} days - 1 day" +"%d"`
        printf "%s %s %s %d %d 00 %f %f %f\n" $year $month $day $hour $minute $bx $by $bz >> omni_${1}.txt
    done < $omni_file

    #this obsolete right now... never a better way to determine when the data is bad.
    if [ $imf_data -eq $bad_imf_data ]
    then
        rm -f omni_${1}.txt  #should I delete the orginal as well?
        echo "Warning: there was no good data in the Omni file"
        return 1;
    fi

    return 0;
}



#--------------------------------------------------
#           MAIN CODE
#--------------------------------------------------

#getopt is a function that takes in the arguements to script and looks for '-' character
#       to determine the option value
#The standard for bash options is '-' is followed by a single character and 
#'--' is followed by a word for better clarity. 
pwd

if [ $# -eq 0 ]
then
    echo "Please provide options to mappot_fitacf, for more infomation on mappot_fitacf options:"
    echo "  mappot_fitacf --help"
    exit -1
fi


options=`getopt -o hH:d:s:e:f:m:v -l help,hemi:,date:,st:,et:,path:,vb -- "$@"`
if [ $? -ne 0 ]
then 
    echo "Please provide options to mappot_fitacf, for more infomation on mappot_fitacf options:"
    echo "  mappot_fitacf --help"
    exit -1
fi



eval set -- "$options"

while true; 
do
    #case switch in bash 
    case "$1" in
        -h | --help ) 
            echo "Usage:"
            echo "  mappot_file [OPTIION] [OPTION INPUT]..."
            echo "example: mappot_file -hemi south -date 20130601"
            echo "Options:"
            echo "  -H | --hemi <south or north>    Hemisphere you are looking at (required)"
            echo "  -d | --date YYYYMMDD            The date you are interested in (required)"
            echo "  -s | --st HH:MM                 start time for the mappotential plots (optional)"
            echo "  -e | --et HH:MM                 end time for the mappotential plots (optional)"
            echo "  -f | --fitacfpath               path to the fitacf data (optional)"
            echo "  -m | --mappath                  path to where the covection maps will be stored based on hemisphere/year/month/day"
            echo "  -o | --ominpath                 path to where the omini will be saved to" 
            echo "  -v | --vb                       verbose (optional)"
            echo "  -h | --help                     help menu on the various options"
            echo "NOTE: if the start time and/or the end time is not provided then it will generate the mappotential plots for the whole day."
            exit 0
            ;;
       -H | --hemi )
            shift
            hemisphere=$1
            ;;
       -d | --date )
            shift
            name=$1
            ;;
       -s | --st )
            shift
            mappot_start_time=$1
            start_time_option="-st $1"
            ;;
       -e | --et )
            shift
            mappot_end_time=$1 
            end_time_option="-et $1"
            ;;
       -p | --path )
            shift
            fitacf_path=$1
            ;;
       -v | --vb )
            verbose="-vb"
            shift
            ;;
        -- )
            shift 
            break
            ;;
        \? )
            echo "Invalid option: --$1" >&2
            exit -1
            ;;
        : )
            echo "Option --$1 requires an arguement." >&2
            echo "Please look at mappot_file -help for option information"
            exit 0
            ;;
    esac #<---- this is cute syntax 
    shift
done

if [ -z $fitacf_path ]
then
    fitacf_path=`pwd`
fi

#sets pipefail to return the last most pipe command that exited
#with a non-zero return value 
set -o pipefail

if ! ls ${fitacf_path}/${name}.* 1> /dev/null 2>&1;
then
    echo "Error: There are no data files for this given date $name"
    exit 2;
fi


#Reads in the data file extensions 
if [ "$hemisphere" == "south" ]
then
    # -f : check for the existance of a file
    # !  : Negation
    if [ ! -f "${MAPPOTEXTENSIONSPATH}/south_extensions" ]
    then 
        echo "Error: south_extensions file is missing"
        echo "       You can download it off the github page: https://github.com/SuperDARNCanada/mapping"
        echo "       Please make sure the MAPPOTEXTENSIONSPATH is set correctly "
        exit -1;
    else
        hemisphere_option="-sh"
        #Reads a file into an array 
        readarray data_extensions < "${MAPPOTEXTENSIONSPATH}/south_extensions"
    fi
elif [ "$hemisphere" == "north" ]
then
    if [ ! -f "${MAPPOTEXTENSIONSPATH}/north_extensions" ]
    then 
        echo "Error: north_extensions file is missing"
        echo "       You can download it off the github page: https://github.com/SuperDARNCanada/mapping"
        echo "       Please make sure the MAPPOTEXTENSIONSPATH is set correctly "
        exit -1;
    else
        hemisphere_option=""
        readarray data_extensions < "${MAPPOTEXTENSIONSPATH}/north_extensions"
    fi
else
    echo "Error: $hemisphere is not an option for the -hemi option, please either use south or north " >&2
    exit -1;
fi

if [ ! -d "${name}_${hemisphere}" ]
then
    mkdir ${name}_${hemisphere}
fi

cd ${name}_${hemisphere} 
error_check $? "cd" -1 

#counter is used to determine how many grid files are created
counter=0

#@ : mean give me everything! 
for data_extension in "${data_extensions[@]}"
do
    file_name=`tr -d " " <<< ${name}.${data_extension}`
    error_check $? "tr" -1

    #if the data does not exist then check for gz file
    #extract the gz file; otherwise throw a warning that the file
    #does not exist
    if [ -z "$fitacf_path" ]
    then
        fitacf_path=".."
    fi

    if [ ! -f "${fitacf_path}/${file_name}" ]
    then
           
        if [ -f "${fitacf_path}/${file_name}.gz"  ]
        then 
           gzip -d ${fitacf_path}/${file_name}.gz 2>&1; 
           error_check $? "gzip" -1;
           cp ${fitacf_path}/${file_name} .;
           error_check $? "cp" -1;
       else
           echo "Warning: ${file_name}.gz does not exist, this file will not be included in the convection map";
           continue;
        fi
                   
    else
        cp ../${file_name} .
        error_check $? "cp" -1;
    fi

    # A case where we do not want to stop if the file is empty
    warning_file_check $file_name
    if [ $? -ne 0 ]
        then
            continue;
    fi

    #use make grid to make grid files :)
    extension=`echo "$data_extension" | cut -d '.' -f2`
    error_check $? "echo | cut" -1;

    #
    #TODO: put this code into a function, make_grid_error_checking? 
    #

    #make_grid options:
    #   -i      : integration time <-- 2 minutes 
    #   -minrng : exclude data from range gates lower than minrange
    #   -fmax   : set the maximum allowed variation in frequency to be fmax Hz
    #   -vemax  : exclude data with a velocity error greater than vemax m/s
    #   -tl tlen: ignore scan flag in the fitacf file and use a fixed scan length tlen 
    if [ "$verbose" == "-vb" ]
    then
        echo "make_grid $verbose -old -i $INTEGRATIONTIME $start_time_option $end_time_option -minrng $MINIMUMRANGE -fmax $FMAX -vemax $VEMAX $file_name > ${name}.${extension}.grid"
    fi

    #dmapdump is an rst function that pasrses the binary fitacf file to a human readable file
    #parse the fitacf file to find scan values of -1 
    #For a few radar -1 is used to inidicate backward scanning however, rst does not handling this 
    #value gracefully and the current fix is to set the option -tl
    scan_flag_error=`dmapdump $file_name | grep -c '\"scan\" = -1'`
    if [ $scan_flag_error -ne 0 ]
    then
        scan_flag_options="-tl 60" # currently using 60 because of new radar scan times
        #this magic number does not seem to have a huge affect on the data however, it is not good practice to 
        #use magic numbers without meaning :(
    else
        scan_flag_options=""
    fi

    channelA=`dmapdump $file_name | grep -c '\"channel\" = 1'`
    channelB=`dmapdump $file_name | grep -c '\"channel\" = 2'`

    if [ $channelA -gt 0 ] && [ $channelB -gt 0 ];
    then
        make_grid $verbose -xtd  -cn A $scan_flag_options -i $INTEGRATIONTIME -minrng $MINIMUMRANGE -fmax $FMAX -vemax $VEMAX $file_name > ${name}.${extension}.A.grid
        warning_check $? "make grid" 
        warning_file_check ${name}.${extension}.A.grid
        warning_return_value=$?

        make_grid $verbose -xtd -cn B $scan_flag_options -i $INTEGRATIONTIME -minrng $MINIMUMRANGE -fmax $FMAX -vemax $VEMAX $file_name > ${name}.${extension}.B.grid
        warning_check $? "make grid" 
        warning_file_check ${name}.${extension}.B.grid
        if [ $? -ne 0 ]
        then
             warning_return_value=$?
        fi

   elif [ $channelA -gt 0 ]
    then 
        make_grid $verbose -xtd -cn A $scan_flag_options -i $INTEGRATIONTIME -minrng $MINIMUMRANGE -fmax $FMAX -vemax $VEMAX $file_name > ${name}.${extension}.A.grid
        warning_check $? "make grid" 
        warning_file_check ${name}.${extension}.A.grid
        warning_return_value=$?

   elif [ $channelB -gt 0 ]
    then
        make_grid $verbose -xtd -cn B $scan_flag_options -i $INTEGRATIONTIME -minrng $MINIMUMRANGE -fmax $FMAX -vemax $VEMAX $file_name > ${name}.${extension}.B.grid
        warning_check $? "make grid" 
        warning_file_check ${name}.${extension}.B.grid
        warning_return_value=$?

    else
        make_grid $verbose -xtd $scan_flag_options -i $INTEGRATIONTIME -minrng $MINIMUMRANGE -fmax $FMAX -vemax $VEMAX $file_name > ${name}.${extension}.grid
        warning_check $? "make grid" 
        warning_file_check ${name}.${extension}.grid
        warning_return_value=$?
    fi
    
    if [ $warning_return_value -eq 0 ]
    then
        counter=$((counter+1))
    fi 

done

if [ $counter -eq 0 ]
then
    echo "Error: No grid files were generated for the $hemisphere hemisphere, please make sure there is data files for the date: $name"
    exit 2;
fi

combine_grid $verbose ${name}.*.grid > ${name}.grd
error_check $? "combine grid" 5
file_check ${name}.grd

#map_grd options:
# -l   : set the lower latitude boundary to latmin <--- 50?
# -sh  : south hemisphere data <-- determined by user input
map_grd $verbose $hemisphere_option -l 50 ${name}.grd > ${name}.empty.map
error_check $? "map grid" 5
file_check ${name}.empty.map


map_addhmb $verbose $hemisphere_option ${name}.empty.map > ${name}.hmb.map
error_check $? "map addhmb" 5
file_check ${name}.hmb.map

if [ ! -f omni_${name}.txt ]
then 
    get_omni_file $name 
    omni_returnvalue=$?
fi

if [ -s omni_${name}.txt ]
then
    
    # map_addimf options:
    # -d  : delay time, format hh:mm
    # -if : read the IMF data from the ASCII text file "imfname"
    map_addimf $verbose -d 00:10 -if omni_${name}.txt ${name}.hmb.map > ${name}.imf.map
    error_check $? "map addimf" 5
    file_check ${name}.imf.map

    imf_extension="imf"
    imf_option="-imf"
    
else
    echo "Warning: IMF file was not generated"
    imf_extension="hmb"
    imf_option=""
fi

#map_addmodel options:
# -o : set the order of fit to be "order" 
# -d : set the doping level to dp. Possible values are low, medium, or high. 
map_addmodel $verbose -o 8 -d l ${name}.${imf_extension}.map > ${name}.model.map
error_check $? "map addmodel" 1
file_check ${name}.model.map 

map_fit $verbose ${name}.model.map > ${name}.map
error_check $? "map fit" 1
file_check ${name}.map


#
#TODO: I wonder if it is possible to get the timstamps of each integration time and then name 
#       each ps file after their times... might be nicer then some arbitrary number 
#       -> map_plot will not do this but we can do this as an extra step if desired

#map_plot options
#   -ps     : output post script convection map files
#   -mag    : magnetic coordinates
#   -rotate : rotate the plot so that the local noon is at the top of the plot 
#   -logo   : plot the logo and credits <---- we probably can take this out 
#   -modn   : plot the name of the statistical model
#   -fit    : plot the fitted two-dimensional velocity vectors
#   -grd    : plot a grd
#   -ctr    : plot potential contours
#   -imf    : use imf data, this will only be used if we have good imf data
#   -extra  : plot extra diagnostic information
#   -coast  : plot the coast line
#   -vecp   : plot the example vector
#   -vkeyp  : plot the color key for the velocity plot 
#   -time   : plot the time of the plotted data
#   -pot    : plot the cross polar cap potential 
#   -vkey   : vector key file, we use rainbow.key
#

#-f : checks if the file exists
if [ ! -f "${KEYFILEPATH}/$KEYFILE" ]
then
    echo "Warning: Missing rainbow.key file, the following map files will be produced with a grey scale"
    key_option="-vkeyp"
else
    cp ${KEYFILEPATH}/$KEYFILE . 
    key_option="-vkeyp -vkey $KEYFILE"
fi
echo $key_option

map_plot -ps -mag $start_time_option $end_time_option -rotate -hmb -modn -fit -grd -ctr ${imf_option} -dn -extra -coast -vecp -pot -time ${key_option} ${name}.map 2>/dev/null
error_check $? "map plot" 1


#Convert ps_files to pdfs 
for ps_file in *.ps 
do
    if [ "$verbose" == "-vb" ]
    then
        echo $ps_file
    fi
    timeout 20 ps2pdf $ps_file
    warning_check $? "ps2pdf $ps_file"
done

cleanup $name
